## BIO存在的问题
- 虽然在服务器端请求的处理交给了一个独立线程进行，但是操作系统通知`accept()`的方式还是当个的，也就是实际上是服务器接收到数据报文后的"业务处理过程"可以多线程，但是数据报文的接受还是需要一个一个来

- 在`Linux`系统中可以创建的线程数有限的。我们可以通过`cat /proc/sys/kernel/threads-max `命令查看可以创建的最大线程数，当然这个值是可以更改的。但是线程越多`CPU`切换锁需的时间也就越长，影响性能
- 创建一个线程有比较大的资源消耗。`JVM`创建一个线程的时候即使这个线程不做任何工作，`JVM`都会分配一个堆栈空间。这个空间的大小默认为`128K`，可以通过`-Xss`参数进行调整
- 另外如果应用程序大量使用长连接的话线程不会关闭，这样系统资源的消耗更容易失控

## 阻塞问题的根源

服务器线程发起一个`accept`动作询问操作系统是否有新的`socket`套接字信息从端口xx发送过来

如果操作系统没有发现有套接字从指定的端口xx来，那么操作系统就会等待。这样`serverSocket.accept()`方法就会一直等待。这就是为什么`accept()`方法为什么会阻塞:**它内部的实现是使用的操作系统级别的同步IO**

同步`IO`和非同步`IO`这两个概念是操作系统级别的。主要描述的是操作系统在收到程序请求`IO`操作后，如果`IO`资源没有准备好，该如何处理相应程序的问题:前者不响应，直到IO资源准备好以后；后者当用户进程请求`I/O`操作时，如果数据还没有准备好它并不会`block`用户进程，而是立刻返回一个`error`