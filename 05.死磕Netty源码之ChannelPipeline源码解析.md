# 前言

ChannelPipeline数据管道是ChannelHandler数据处理器的容器，负责ChannelHandler的管理和事件的拦截与调度

# 源码分析

## 初始化

在Channel初始化时会调用到AbstractChannel的构造方法，pipeline的初始化动作是在AbstractChannel构造方法中完成的
```
protected AbstractChannel(Channel parent) {
    this.parent = parent;
    id = newId();
    unsafe = newUnsafe();
    pipeline = newChannelPipeline();
}
```
接下来我们继续跟进newChannelPipeline()，探究一下DefaultChannelPipeline底层实现细节
```
protected DefaultChannelPipeline newChannelPipeline() {
    return new DefaultChannelPipeline(this);
}

protected DefaultChannelPipeline(Channel channel) {
    this.channel = ObjectUtil.checkNotNull(channel, "channel");

    tail = new TailContext(this);
    head = new HeadContext(this);

    head.next = tail;
    tail.prev = head;
}
```
在newChannelPipeline()中调用了DefaultChannelPipeline的构造方法，DefaultChannelPipeline构造方法主要完成了三件事。首先将与之关联的Channel保存在属性Channel中，然后实例化了两个对象(一个是TailContext实例tail，一个是HeadContext实例head)，然后将head和tail相互指向构成了一个双向链表。数据结构如下图
![ChannelPipeline数据结构](https://raw.githubusercontent.com/RobertoHuang/RGP-IMAGE/master/%E6%AD%BB%E7%A3%95NETTY%E6%BA%90%E7%A0%81/%E6%AD%BB%E7%A3%95Netty%E6%BA%90%E7%A0%81%E4%B9%8BChannelPipeline%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/ChannelPipeline%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)
DefaultChannelPipeline中的每个节点是一个ChannelHandlerContext对象，每个ChannelHandlerContext节点保存了它包裹的执行器ChannelHandler执行操作所需要的上下文(其实就是Pipeline，因为Pipeline包含Channel的引用可以拿到所有Context信息)

## 添加节点

我们在初始化bootstrap的时候应该对下面这段代码不陌生，它是将ChannelHandler添加到pipeline的双向链表中去的
```
bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {
    @Override
    protected void initChannel(SocketChannel socketChannel) throws Exception {
        socketChannel.pipeline().addLast(new NettyMessageDecoder(serializer));
        socketChannel.pipeline().addLast(new NettyMessageEncoder(serializer));
    }
})
```
下面我们来跟下addLast方法
```
public final ChannelPipeline addLast(ChannelHandler... handlers) {
    return addLast(null, handlers);
}

public final ChannelPipeline addLast(EventExecutorGroup executor, ChannelHandler... handlers) {
    if (handlers == null) {
        throw new NullPointerException("handlers");
    }
    for (ChannelHandler h: handlers) {
        if (h == null) {
            break;
        }
        addLast(executor, null, h);
    }
    return this;
}

public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) {
    final AbstractChannelHandlerContext newCtx;
    synchronized (this) {
        // 1.禁止非Sharable的handler重复添加到不同的pipeline中
        checkMultiplicity(handler);

        // 2.创建节点 => DefaultChannelHandlerContext
        newCtx = newContext(group, filterName(name, handler), handler);

        // 3.添加节点
        addLast0(newCtx);

        // 如果channel没有与eventloop绑定
        // 则创建一个任务 这个任务会在channel被register的时候调用
        if (!registered) {
            newCtx.setAddPending();
            callHandlerCallbackLater(newCtx, true);
            return this;
        }

        // 4.回调用户方法
        EventExecutor executor = newCtx.executor();
        if (!executor.inEventLoop()) {
            newCtx.setAddPending();
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    callHandlerAdded0(newCtx);
                }
            });
            return this;
        }
    }
    callHandlerAdded0(newCtx);
    return this;
}
```
### 检查是否有重复Handler

检查是否有重复Handler的实现在checkMultiplicity()方法中
```
private static void checkMultiplicity(ChannelHandler handler) {
    if (handler instanceof ChannelHandlerAdapter) {
        ChannelHandlerAdapter h = (ChannelHandlerAdapter) handler;
        if (!h.isSharable() && h.added) {
            throw new ChannelPipelineException(h.getClass().getName() + " is not a @Sharable handler, so can't be added or removed multiple times.");
        }
        h.added = true;
    }
}
```
ChannelHandlerAdapter使用一个成员变量added标识一个Channel是否已经添加过，如果当前要添加的Handler是非共享并且已经添加过那就抛出异常，否则标识该Handler已经添加。由此可见一个Handler如果是Sharable的就可以无限次被添加到Pipeline中，我们客户端代码如果要让一个Handler被共用，只需要加一个@Sharable标注即。而如果Handler是Sharable的一般就通过Spring的注入的方式使用，不需要每次都新建对象

### 创建节点DefaultChannelHandlerContext

创建节点调用了newContext()方法，代码如下
```
newCtx = newContext(group, filterName(name, handler), handler);
```

